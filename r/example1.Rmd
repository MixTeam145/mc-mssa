---
title: "Example"
output: html_document
---

```{r, include=FALSE}
source("mcmssa_utils.R")
library(foreach)
library(doSNOW)
library(parallel)
library(doRNG)
library(tidyr)

load("example.RData")
recalculate.correction <- FALSE
```

```{r}
df <- read.table("data/data.txt", na.strings = -99.99)
df <- na.omit(df)
names(df) <- c("year", 1:12)
df <- df |> pivot_longer(cols = 2:13, names_to = "month", values_to = "temperature")
df.year_mean <- df |> group_by(year) |> summarise(temperature = mean(temperature))
f <- ts(df$temperature, start = 1950, frequency = 12)
f.year_mean <- ts(df.year_mean$temperature, start = 1950)
plot(f)
plot(f.year_mean)
f_mean <- f - sapply(1:12, function(month) mean(f[seq(month, length(f), 12)]))
```

В этом ряде присутствует тренд, выделим его.
```{r}
s <- ssa(f, L = 120)
plot(s, type = "vector", idx = 1:20)
plot(s, type = "paired", idx = 1:20)
```

```{r}
r <- reconstruct(s, groups = list(Trend = 1))
#pdf(file = "Nino_reconstruct_trend.pdf", width = 15, height = 8)
plot(r, add.residuals = FALSE, plot.method = "xyplot", superpose = TRUE)
#dev.off()
#f <- resid(r)
model <- est.model.arima(resid(r))
#model$signal <- as.vector(r$trend + r$season.year)

```

```{r}
s1 <- ssa(resid(r), kind = "toeplitz-ssa")
plot(s1, type = "vector", idx = 1:20)
plot(s1, type = "paired", idx = 1:20)
```

```{r}
r1 <- reconstruct(s1, groups = list(season.year = 1:2))
#pdf(file = "Nino_reconstruct_season.pdf", width = 15, height = 8)
plot(r1, add.residuals = FALSE, plot.method = "xyplot", superpose = TRUE)
#dev.off()
model <- est.model.arima(resid(r1))
```

Построим поправку для $L=40$
```{r}
L <- 40
M <- 1000
G <- 1000
alphas <- 0:1000 / 1000
alphas_idx <- seq_along(alphas)
```

```{r}
pb <- txtProgressBar(max = M, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)
```

```{r}
if (recalculate.correction) {
  cores <- detectCores()
  cluster <- makeCluster(cores - 1)
  registerDoSNOW(cluster)
  registerDoRNG(seed = 1, once = FALSE)
  p.values_noise <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = c('Norm', 'rowQuantiles'),
    .packages = "Rssa",
    .options.snow = opts
  ) %dopar% {
    f0 <- one.channel.ts(model, 0)
    res <-
      MonteCarloSSA(
        f = f0,
        L = L,
        model = model,
        basis = "ev",
        kind = "ev",
        D = 1,
        G = G,
        level.conf = NULL
      )
    res$p.value
  }
  stopCluster(cluster)
}
```

```{r}
alpha.corrected <- correction(p.values_noise)
```
Применим поправленный MC-SSA.
```{r}
set.seed(5)
m <-
  MonteCarloSSA(
    resid(r),
    model = model,
    L = 40,
    D = 1,
    basis = "ev",
    kind = "ev",
    G = G,
    level.conf = 0.95,
  )

#pdf(file = "Nino_mcssa.pdf", width = 15, height = 8)
plot.ci(m, log_ = TRUE)
#dev.off()

1/m$freq[m$v > m$upper]
```

Обнаружилось 4 компоненты, легко интерпретируемые компоненты с периодом 6 -- полугодовая сезонность. Сначала найдем компоненты с периодом, близким к 6.
```{r}
s2 <- ssa(resid(r1), kind = "toeplitz-ssa")
freq <- numeric(0)
for (i in 1:nu(s2)) {
  ss <- ssa(s2$U[, i], kind = "1d-ssa")
  p <- parestimate(ss, groups = list(1:2))
  freq[i] <- p$frequencies[[1]]
}
order(abs(1/freq - 6))[1:2]
1/freq[order(abs(1/freq - 6))[1:2]]
```
Это компоненты 18 и 19. Выделим их.
```{r}
r2 <- reconstruct(s2, groups = list(season.halfyear = 18:19))
plot(r2, add.original = FALSE)
```

```{r}
model2 <- est.model.arima(resid(r2))
```

Сделаем новую поправку.
```{r}
if (recalculate.correction) {
  cores <- detectCores()
  cluster <- makeCluster(cores - 1)
  registerDoSNOW(cluster)
  registerDoRNG(seed = 1, once = FALSE)
  p.values_noise2 <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = c('Norm', 'rowQuantiles'),
    .packages = "Rssa",
    .options.snow = opts
  ) %dopar% {
    f0 <- one.channel.ts(model2, 0)
    res <-
      MonteCarloSSA(
        f = f0,
        L = L,
        model = model2,
        basis = "ev",
        kind = "ev",
        D = 1,
        G = G,
        level.conf = NULL
      )
    res$p.value
  }
  stopCluster(cluster)
}
```

```{r}
alpha.corrected2 <- correction(p.values_noise2)
```

Повторно применим MC-SSA.
```{r}
set.seed(5)
m2 <-
  MonteCarloSSA(
    resid(r),
    L = 40,
    model = model2,
    D = 1,
    basis = "ev",
    kind = "ev",
    G = G,
    level.conf = 0.95,
    freq.range = c(0, 0.5)
  )

plot.ci(m2, log_ = TRUE)

1/m2$freq[m2$v > m2$upper]
```

```{r}
df2 <- read.table("hadCET.txt", na.strings = -99.9, header = TRUE)
df2 <- na.omit(df2)
f2 <- ts(rowMeans(df2[, -c(1,14)]), start = 1659)
```

```{r}
s.2 <- ssa(f2, L=80)
r.2 <- reconstruct(s.2, list(1))
plot(r.2)
```

```{r}
set.seed(5)
m.2 <- MonteCarloSSA(resid(r.2), L = 60, D = 1, basis = "ev", kind = "ev", level.conf = 0.95)
plot.ci(m.2)
m.2$freq[m.2$v > m.2$upper]
```

```{r}
s.22 <- ssa(resid(r.2), L=60, kind = "toeplitz-ssa")
freq2 <- numeric(0)
for (i in 1:nu(s.22)) {
  ss <- ssa(s.22$U[, i], kind = "1d-ssa")
  p <- parestimate(ss, groups = list(1:2))
  freq2[i] <- p$frequencies[[1]]
}

r.22 <- reconstruct(s.22, list(9:10))
```


```{r}
set.seed(5)
model <- est.model.arima(resid(r.22))
m.22 <- MonteCarloSSA(resid(r.2), model = model, L = 60, D = 1, basis = "ev", kind = "ev", level.conf = 0.95)
plot.ci(m.22)
```


