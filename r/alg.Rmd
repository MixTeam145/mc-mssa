---
title: "Алгоритм выбора длины окна"
output:
  html_document:
    df_print: paged
---

```{r, include=FALSE}
source("mcmssa_utils.R")
library(foreach)
library(doSNOW)
library(parallel)
library(doRNG)
```

```{r}
optimize.mcssa <-
  function(model,
           signif.level,
           alphaI_threshold,
           interval,
           M = 1000,
           G = 1000,
           tol = 0.01) {
    L_left <- interval[1]
    L_right <- interval[2]
    
    cores <- detectCores()
    cluster <- makeCluster(cores - 1)
    registerDoSNOW(cluster)
    registerDoRNG(seed = 1)
    
    rejected <- foreach (
        i = 1:M,
        .combine = '+',
        .export = c('Norm', 'rowQuantiles'),
        .options.snow = opts,
        .options.RNG = 1
      ) %dopar% {
        source("mcmssa_utils.R", local = TRUE)
        noise <- one.channel.ts(model, 0)
        m1 <-
          MonteCarloSSA(
            noise,
            model = model,
            L = L_left,
            D = 1,
            basis = "ev",
            kind = "ev",
            G = G,
            level.conf = 1 - signif.level
          )
        m2 <-
          MonteCarloSSA(
            noise,
            model = model,
            L = L_right,
            D = 1,
            basis = "ev",
            kind = "ev",
            G = G,
            level.conf = 1 - signif.level
          )
        c(m1$reject, m2$reject)
      }
    
    print(c(sprintf("L=%d", L_left), rejected[1] / M))
    print(c(sprintf("L=%d", L_right), rejected[2] / M))
    
    if (rejected[2] / M <= alphaI_threshold)
      return(L_right)
    else if (abs(rejected[1] / M - alphaI_threshold) < tol)
      return(L_left)
    else if (rejected[1] / M > alphaI_threshold)
      stop("There is no such L that alphaI < alphaI_threshold")

    while (L_right - L_left > 5) {
      L_mid <- floor((L_right + L_left) / 2)
      rejected <- foreach (
        i = 1:M,
        .combine = '+',
        .export = c('Norm', 'rowQuantiles'),
        .packages = "Rssa",
        .options.snow = opts,
        .options.RNG = 1
      ) %dopar% {
        source("mcmssa_utils.R", local = TRUE)
        noise <- one.channel.ts(model, 0)
        m <-
          MonteCarloSSA(
            noise,
            model = model,
            L = L_mid,
            D = 1,
            basis = "ev",
            kind = "ev",
            G = G,
            level.conf = 1 - signif.level
          )
        m$reject
      }
      alphaI <- rejected / M
      print(c(sprintf("L=%d", L_mid), alphaI))
      if (abs(alphaI - alphaI_threshold) < tol)
        return(L_mid)
      if (alphaI < alphaI_threshold)
        L_left = L_mid
      if (alphaI > alphaI_threshold)
        L_right = L_mid
    }
    stopCluster(cluster)
    L_left
  }
```

Параметры функции optimize.mcssa:

1. **sign.level** --- уровень значимости $\alpha$

2. **alphaI_threshold** --- порог ошибки I рода $\alpha_I(\alpha)$

3. **interval** --- интервал поиска оптимального значения L

4. **M** --- количество моделируемых рядов для вычисления $\alpha_I(\alpha)$

5. **G** --- количество суррогатных реализаций

6. **tol** --- желаемая точность

# Пример
```{r}
N <- 200
varphi <- 0.35
delta <- 1
model <- list(varphi = varphi,
              delta = delta,
              N = N)
M <- 500
G <- 1000
omega <- 0.075
A <- 0.6
signal <- signal.one.channel(model$N, omega, A)
```

```{r, include=FALSE}
pb <- txtProgressBar(max = M, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)
```

```{r, results='hide'}
L_optim <-
  optimize.mcssa(
    model,
    signif.level = 0.05,
    alphaI_threshold = 0.5,
    interval = c(100, 190),
    M = M,
    G = G
  )
```

```{r}
L_optim
```

Построим ROC-кривые и сравним критерии для разных длин окна.

```{r}
alphas <- 0:1000/1000
clrs <- c('black', 'red', 'green', 'orange', 'purple')
lwds <- c(2, 1, 1, 1, 2)
Ls <- c(100, 130, 160, 190, L_optim)
```

```{r, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_noise_phi.3_N200 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = c('Norm', 'rowQuantiles'),
    .packages = "Rssa",
    .options.snow = opts
  ) %dopar% {
    f <- one.channel.ts(model, 0)
    res <-
      MonteCarloSSA(
        f = f,
        L = Ls[idx],
        model = model,
        basis = "ev",
        kind = "ev",
        D = 1,
        G = G,
        level.conf = NULL
      )
    res$p.value
  }
  p.values_noise_phi.3_N200[[idx]] <- result
}

stopCluster(cluster)
```

```{r, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_signal_phi.3_N200 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = c('Norm', 'rowQuantiles'),
    .packages = "Rssa",
    .options.snow = opts
  ) %dopar% {
    f <- one.channel.ts(model, signal)
    res <-
      MonteCarloSSA(
        f = f,
        L = Ls[idx],
        model = model,
        basis = "ev",
        kind = "ev",
        D = 1,
        G = G,
        level.conf = NULL
      )
    res$p.value
  }
  p.values_signal_phi.3_N200[[idx]] <- result
}

stopCluster(cluster)
```

```{r}
alphaI <- lapply(p.values_noise_phi.3_N200, function(pvals) sapply(alphas, function(a) sum(pvals < a) / M))
beta <- lapply(p.values_signal_phi.3_N200, function(pvals) sapply(alphas, function(a) sum(pvals < a) / M))
```

```{r}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'significance level', ylab = 'type I error')
for (i in seq_along(Ls)[-5])
  lines(alphas, alphaI[[i]], lwd = lwds[i], col = clrs[i])
legend(x = "bottomright", as.character(Ls)[-5], col = clrs, lty = 1, lwd = lwds)
```

```{r}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power')
lines(alphaI[[4]][-1], beta[[4]][-1], lwd = lwds[4], col = clrs[4])
lines(alphaI[[3]][-1], beta[[3]][-1], lwd = lwds[3], col = clrs[3])
for (i in seq_along(Ls)[c(-3, -4)]) {
  lines(alphaI[[i]], beta[[i]], lwd = lwds[i], col = clrs[i])
}
legend(x = "bottomright", as.character(Ls), col = clrs, lty = 1, lwd = lwds)
```
