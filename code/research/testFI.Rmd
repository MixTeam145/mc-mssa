---
title: "Сравнение MC-SSA с критериями проверки ряда на белый шум"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(foreach)
library(doSNOW)
library(parallel)
library(doRNG)

source("../R/mc-mssa.R", chdir = TRUE)
load("../research/data/testFI.RData")
```

Сравним MC-SSA с критерием Ljung-Box (далее box) и `genwwn.test` (далее wavelet) из пакета `hwwntest`. Поскольку два последних критерия проверяют гипотезу о том, что ряд представляет собой белый шум, будем проверять гипотезу следующим образом:

1. Подогнать исходный временной ряд под выбранную модель шума и вычислить остаток;

2. Применить к остатку критерий проверки ряда на белый шум.

Рассмотрим модель $\mathrm{ARFIMA}(0, d, 0)$ с $d=0.4$ и $\sigma^2=1$. В качестве векторов для проекции возьмем собственные векторы матрицы $\mathbf{X}\mathbf{X}^\mathrm{T}$. Оценивать параметр $d$ будем с помощью метода Whittle. В критерии box будем использовать первые $10$ лагов, а поскольку параметр $d$ оценивается, количество степеней свободы будем брать меньше на $1$.
```{r}
d <- 0.4
sigma2 <- 1
N <- 128
model <- list(dfrac = d, sigma2 = sigma2, N = N)
```

```{r}
omega1 <- 0.025
signal1 <- 1.5 *  cos(2 * pi * (1:N) * omega1)

omega2 <- 0.125
signal2 <- 0.6 *  cos(2 * pi * (1:N) * omega2)

omega3 <- 0.225
signal3 <- 0.5 *  cos(2 * pi * (1:N) * omega3)
```

```{r eval=FALSE, include=FALSE}
M <- 1000
pb <- txtProgressBar(max = M, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

functions <- c("Norm", "rowQuantiles")
packages <- c("Rssa", "arfima")
```

```{r}
Ls <- c(12, 24, 64, 104, 116)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_noise_mcssa_fi <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model)
    model_est <- arfima_whittle(f, c(0, NA))
    model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
    res$p.value
  }
  p.values_noise_mcssa_fi[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_signal1_mcssa_fi <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model, signal1)
    model_est <- arfima_whittle(f, c(0, NA))
    model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
    res$p.value
  }
  p.values_signal1_mcssa_fi[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_signal2_mcssa_fi <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model, signal2)
    model_est <- arfima_whittle(f, c(0, NA))
    model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
    res$p.value
  }
  p.values_signal2_mcssa_fi[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_signal3_mcssa_fi <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model, signal3)
    model_est <- arfima_whittle(f, c(0, NA))
    model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
    res$p.value
  }
  p.values_signal3_mcssa_fi[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
p.values_noise_box_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_noise_box_fi <- c(p.values_noise_box_fi, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal1_box_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal1)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal1_box_fi <- c(p.values_signal1_box_fi, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal2_box_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal2)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal2_box_fi <- c(p.values_signal2_box_fi, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal3_box_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal3)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal3_box_fi <- c(p.values_signal3_box_fi, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_noise_wavelet_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_noise_wavelet_fi <- c(p.values_noise_wavelet_fi, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal1_wavelet_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal1)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal1_wavelet_fi <- c(p.values_signal1_wavelet_fi, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal2_wavelet_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal2)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal2_wavelet_fi <- c(p.values_signal2_wavelet_fi, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal3_wavelet_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal3)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal3_wavelet_fi <- c(p.values_signal3_wavelet_fi, genwwn.test(resid)$p.value)
}
```

```{r include=FALSE}
alphas <- 0:1000/1000
clrs <- c('black', 'red', 'green', "orange", "purple")
lwds <- c(2, 1, 1, 1, 1)

alphaI_mcssa <- lapply(p.values_noise_mcssa_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
alphaI_box <- sapply(alphas, function(a) mean(p.values_noise_box_fi < a))
alphaI_wavelet <- sapply(alphas, function(a) mean(p.values_noise_wavelet_fi < a))

beta_mcssa1 <- lapply(p.values_signal1_mcssa_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_mcssa2 <- lapply(p.values_signal2_mcssa_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_mcssa3 <- lapply(p.values_signal3_mcssa_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))

beta_box1 <- sapply(alphas, function(a) mean(p.values_signal1_box_fi < a))
beta_box2 <- sapply(alphas, function(a) mean(p.values_signal2_box_fi < a))
beta_box3 <- sapply(alphas, function(a) mean(p.values_signal3_box_fi < a))

beta_wavelet1 <- sapply(alphas, function(a) mean(p.values_signal1_wavelet_fi < a))
beta_wavelet2 <- sapply(alphas, function(a) mean(p.values_signal2_wavelet_fi < a))
beta_wavelet3 <- sapply(alphas, function(a) mean(p.values_signal3_wavelet_fi < a))
```

Ошибка первого рода:

```{r echo=FALSE}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = "significance level", ylab = 'type I error')
for (i in seq_along(Ls))
  lines(alphas, alphaI_mcssa[[i]], lwd = lwds[i], col = clrs[i])
lines(alphas, alphaI_box, lwd = 3, col = "darkblue")
lines(alphas, alphaI_wavelet, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

ROC-кривые:

1. $\omega=0.025$

```{r echo=FALSE}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power')

for (i in seq_along(Ls))
  lines(alphaI_mcssa[[i]][-1], beta_mcssa1[[i]][-1], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box1, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet1, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

При косинусе с частотой $\omega=0.025$ в альтернативе мощность двух критериев сравнима с мощностью MC-SSA с $L=24$.

2. $\omega=0.125$

```{r echo=FALSE}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power')

for (i in seq_along(Ls))
  lines(alphaI_mcssa[[i]][-1], beta_mcssa2[[i]][-1], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box2, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet2, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

3. $\omega=0.225$

```{r echo=FALSE}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power')

for (i in seq_along(Ls))
  lines(alphaI_mcssa[[i]][-1], beta_mcssa3[[i]][-1], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box3, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet3, lwd = 3, col = "brown")
legend(
  x = "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

В случае малых частот ($\omega=0.025$) оба критерия имеют мощность больше, чем у MC-SSA с $L=12$. В случае средних частот ($\omega=0.125$) wavelet слабее MC-SSA с $L=12$, box --- мощнее. В случае больших частот ($\omega=0.225$) wavelet и box дают мощность меньше, чем у MC-SSA с $L=12$.
