---
title: "Сравнение MC-SSA с критериями проверки ряда на белый шум"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(foreach)
library(doSNOW)
library(parallel)
library(doRNG)
library(hwwntest)

source("../R/mc-mssa.R", chdir = TRUE)
load("../research/data/tests_comparison.RData")
```

Сравним MC-SSA с критерием Ljung-Box (далее box) и `genwwn.test` (далее wavelet) из пакета `hwwntest`. Поскольку два последних критерия проверяют гипотезу о том, что ряд представляет собой белый шум, будем проверять гипотезу следующим образом:

1. Подогнать исходный временной ряд под выбранную модель шума и вычислить остаток;

2. Применить к остатку критерий проверки ряда на белый шум.

Рассмотрим модель $\mathrm{ARFIMA}(0, d, 0)$ с $d=0.4$ и $\sigma^2=1$. В качестве векторов для проекции возьмем собственные векторы матрицы $\mathbf{X}\mathbf{X}^\mathrm{T}$ и косинусы с частотами $j/(2L)$. Оценивать параметр $d$ будем с помощью метода Whittle. В критерии box будем использовать первые $10$ лагов, а поскольку параметр $d$ оценивается, количество степеней свободы будем брать меньше на $1$.
```{r}
d <- 0.4
sigma2 <- 1
N <- 128
model <- list(dfrac = d, sigma2 = sigma2, N = N)
```

```{r}
omega1 <- 0.025
signal1 <- 1.5 *  cos(2 * pi * (1:N) * omega1)

omega2 <- 0.125
signal2 <- 0.6 *  cos(2 * pi * (1:N) * omega2)

omega3 <- 0.225
signal3 <- 0.5 *  cos(2 * pi * (1:N) * omega3)
```

```{r eval=FALSE, include=FALSE}
M <- 1000
pb <- txtProgressBar(max = M, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)

functions <- c("Norm", "rowQuantiles")
packages <- c("Rssa", "arfima")
```

```{r}
Ls <- c(12, 24, 64, 104, 116)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

# p.values_noise_mcssa_fi <- list()
# for (idx in seq_along(Ls)) {
#   result <- foreach (
#     i = 1:M,
#     .combine = 'c',
#     .export = functions,
#     .packages = packages,
#     .options.snow = opts
#   ) %dopar% {
#     f <- generate_channel(model)
#     model_est <- arfima_whittle(f, c(0, NA))
#     model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
#     res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
#     res$p.value
#   }
#   p.values_noise_mcssa_fi[[idx]] <- result
# }

p.values_noise_cos_fi <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model)
    model_est <- arfima_whittle(f, c(0, NA))
    model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "cos", model0 = model_est, conf.level = NULL)
    res$p.value
  }
  p.values_noise_cos_fi[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

# p.values_signal1_mcssa_fi <- list()
# for (idx in seq_along(Ls)) {
#   result <- foreach (
#     i = 1:M,
#     .combine = 'c',
#     .export = functions,
#     .packages = packages,
#     .options.snow = opts
#   ) %dopar% {
#     f <- generate_channel(model, signal1)
#     model_est <- arfima_whittle(f, c(0, NA))
#     model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
#     res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
#     res$p.value
#   }
#   p.values_signal1_mcssa_fi[[idx]] <- result
# }

p.values_signal1_cos_fi <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model, signal1)
    model_est <- arfima_whittle(f, c(0, NA))
    model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "cos", model0 = model_est, conf.level = NULL)
    res$p.value
  }
  p.values_signal1_cos_fi[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

# p.values_signal2_mcssa_fi <- list()
# for (idx in seq_along(Ls)) {
#   result <- foreach (
#     i = 1:M,
#     .combine = 'c',
#     .export = functions,
#     .packages = packages,
#     .options.snow = opts
#   ) %dopar% {
#     f <- generate_channel(model, signal2)
#     model_est <- arfima_whittle(f, c(0, NA))
#     model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
#     res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
#     res$p.value
#   }
#   p.values_signal2_mcssa_fi[[idx]] <- result
# }

p.values_signal2_cos_fi <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model, signal2)
    model_est <- arfima_whittle(f, c(0, NA))
    model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "cos", model0 = model_est, conf.level = NULL)
    res$p.value
  }
  p.values_signal2_cos_fi[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

# p.values_signal3_mcssa_fi <- list()
# for (idx in seq_along(Ls)) {
#   result <- foreach (
#     i = 1:M,
#     .combine = 'c',
#     .export = functions,
#     .packages = packages,
#     .options.snow = opts
#   ) %dopar% {
#     f <- generate_channel(model, signal3)
#     model_est <- arfima_whittle(f, c(0, NA))
#     model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
#     res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
#     res$p.value
#   }
#   p.values_signal3_mcssa_fi[[idx]] <- result
# }

p.values_signal3_cos_fi <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model, signal3)
    model_est <- arfima_whittle(f, c(0, NA))
    model_est <- list(dfrac = model_est["d"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "cos", model0 = model_est, conf.level = NULL)
    res$p.value
  }
  p.values_signal3_cos_fi[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
p.values_noise_box_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_noise_box_fi <- c(p.values_noise_box_fi, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal1_box_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal1)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal1_box_fi <- c(p.values_signal1_box_fi, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal2_box_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal2)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal2_box_fi <- c(p.values_signal2_box_fi, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal3_box_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal3)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal3_box_fi <- c(p.values_signal3_box_fi, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_noise_wavelet_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_noise_wavelet_fi <- c(p.values_noise_wavelet_fi, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal1_wavelet_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal1)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal1_wavelet_fi <- c(p.values_signal1_wavelet_fi, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal2_wavelet_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal2)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal2_wavelet_fi <- c(p.values_signal2_wavelet_fi, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal3_wavelet_fi <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model, signal3)
  model_est <- arfima_whittle(f, c(0, NA))
  resid <- fracdiff::diffseries(f, model_est["d"])
  p.values_signal3_wavelet_fi <- c(p.values_signal3_wavelet_fi, genwwn.test(resid)$p.value)
}
```

```{r include=FALSE}
alphas <- 0:1000/1000
clrs <- c('black', 'red', 'green', "orange", "purple")
lwds <- c(2, 1, 1, 1, 1)

alphaI_mcssa <- lapply(p.values_noise_mcssa_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
alphaI_box <- sapply(alphas, function(a) mean(p.values_noise_box_fi < a))
alphaI_wavelet <- sapply(alphas, function(a) mean(p.values_noise_wavelet_fi < a))

alphaI_cos <- lapply(p.values_noise_cos_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))

beta_mcssa1 <- lapply(p.values_signal1_mcssa_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_mcssa2 <- lapply(p.values_signal2_mcssa_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_mcssa3 <- lapply(p.values_signal3_mcssa_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))

beta_cos1 <- lapply(p.values_signal1_cos_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_cos2 <- lapply(p.values_signal2_cos_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_cos3 <- lapply(p.values_signal3_cos_fi, function(pvals) sapply(alphas, function(a) mean(pvals < a)))

beta_box1 <- sapply(alphas, function(a) mean(p.values_signal1_box_fi < a))
beta_box2 <- sapply(alphas, function(a) mean(p.values_signal2_box_fi < a))
beta_box3 <- sapply(alphas, function(a) mean(p.values_signal3_box_fi < a))

beta_wavelet1 <- sapply(alphas, function(a) mean(p.values_signal1_wavelet_fi < a))
beta_wavelet2 <- sapply(alphas, function(a) mean(p.values_signal2_wavelet_fi < a))
beta_wavelet3 <- sapply(alphas, function(a) mean(p.values_signal3_wavelet_fi < a))
```

Сначала рассмотрим собственные векторы в качестве векторов для проекции. Ошибка первого рода:

```{r echo=FALSE}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = "significance level", ylab = 'type I error')
for (i in seq_along(Ls))
  lines(alphas, alphaI_mcssa[[i]], lwd = lwds[i], col = clrs[i])
lines(alphas, alphaI_box, lwd = 3, col = "darkblue")
lines(alphas, alphaI_wavelet, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

ROC-кривые:

```{r echo=FALSE, fig.width=15}
par(mfrow = c(1, 3))

plot(c(0, 1), c(0, 1), type = "l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.025")
for (i in seq_along(Ls))
  lines(alphaI_mcssa[[i]][-1], beta_mcssa1[[i]][-1], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box1, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet1, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0, 1), c(0, 1), type = "l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.125")
for (i in seq_along(Ls))
  lines(alphaI_mcssa[[i]][-1], beta_mcssa2[[i]][-1], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box2, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet2, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0, 1), c(0, 1), type = "l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.225")
for (i in seq_along(Ls))
  lines(alphaI_mcssa[[i]][-1], beta_mcssa3[[i]][-1], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box3, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet3, lwd = 3, col = "brown")
legend(
  x = "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

В случае малых частот ($\omega=0.025$) оба критерия имеют мощность больше, чем у MC-SSA с $L=12$. В случае средних частот ($\omega=0.125$) wavelet слабее MC-SSA с $L=12$, box --- мощнее. В случае больших частот ($\omega=0.225$) wavelet и box дают мощность меньше, чем у MC-SSA с $L=12$.


Теперь перейдем к косинусам. Ошибка первого рода:

```{r echo=FALSE}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = "significance level", ylab = 'type I error')
for (i in seq_along(Ls))
  lines(alphas, alphaI_cos[[i]], lwd = lwds[i], col = clrs[i])
lines(alphas, alphaI_box, lwd = 3, col = "darkblue")
lines(alphas, alphaI_wavelet, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

ROC-кривые:

```{r echo=FALSE, fig.width=15}
par(mfrow = c(1, 3))
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.025")

for (i in seq_along(Ls))
  lines(alphaI_cos[[i]], beta_cos1[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box1, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet1, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.125")

for (i in seq_along(Ls))
  lines(alphaI_cos[[i]], beta_cos2[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box2, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet2, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.225")

for (i in seq_along(Ls))
  lines(alphaI_cos[[i]], beta_cos3[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box3, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet3, lwd = 3, col = "brown")
legend(
  x = "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

Если к этому варианту MC-SSA применять поправку, то критерии box и wavelet по мощности не превосходят MC-SSA с $L=12$. Если же забить на поправку (только MC-SSA, чтобы уменьшить трудоемкость, для двух других критериев поправка строится быстро), то оба критерия становятся мощнее MC-SSA с $L=12$.

```{r echo=FALSE, fig.width=15}
par(mfrow = c(1, 3))

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.025")
for (i in seq_along(Ls))
  lines(alphas, beta_cos1[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box1, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet1, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.125")
for (i in seq_along(Ls))
  lines(alphas, beta_cos2[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box2, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet2, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.225")
for (i in seq_along(Ls))
  lines(alphas, beta_cos3[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box3, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet3, lwd = 3, col = "brown")
legend(
  x = "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```


Теперь сделаем тоже самое, только с моделью $\mathrm{AR}(1)$ с $\phi=0.7$, $\sigma^2=1$.
```{r}
phi <- 0.7
model2 <- list(phi = phi, sigma2 = sigma2, N = N)
```

```{r}
signal1 <- 3 *  cos(2 * pi * (1:N) * omega1)

signal2 <- 0.7 *  cos(2 * pi * (1:N) * omega2)

signal3 <- 0.5 *  cos(2 * pi * (1:N) * omega3)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_noise_me_ar1 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model2)
    model_est <- arfima_whittle(f, c(NA, 0))
    model_est <- list(phi = model_est["phi"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
    res$p.value
  }
  p.values_noise_me_ar1[[idx]] <- result
}

p.values_noise_mcos_ar1 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model2)
    model_est <- arfima_whittle(f, c(NA, 0))
    model_est <- list(phi = model_est["phi"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "cos", model0 = model_est, conf.level = NULL)
    res$p.value
  }
  p.values_noise_mcos_ar1[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_signal1_me_ar1 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model2, signal1)
    model_est <- arfima_whittle(f, c(NA, 0))
    model_est <- list(phi = model_est["phi"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
    res$p.value
  }
  p.values_signal1_me_ar1[[idx]] <- result
}

p.values_signal1_mcos_ar1 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model2, signal1)
    model_est <- arfima_whittle(f, c(NA, 0))
    model_est <- list(phi = model_est["phi"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "cos", model0 = model_est, conf.level = NULL)
    res$p.value
  }
  p.values_signal1_mcos_ar1[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_signal2_me_ar1 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model2, signal2)
    model_est <- arfima_whittle(f, c(NA, 0))
    model_est <- list(phi = model_est["phi"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
    res$p.value
  }
  p.values_signal2_me_ar1[[idx]] <- result
}

p.values_signal2_mcos_ar1 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model2, signal2)
    model_est <- arfima_whittle(f, c(NA, 0))
    model_est <- list(phi = model_est["phi"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "cos", model0 = model_est, conf.level = NULL)
    res$p.value
  }
  p.values_signal2_mcos_ar1[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
cores <- detectCores()
cluster <- makeCluster(cores - 1)
registerDoSNOW(cluster)
registerDoRNG(seed = 1, once = FALSE)

p.values_signal3_me_ar1 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model2, signal3)
    model_est <- arfima_whittle(f, c(NA, 0))
    model_est <- list(phi = model_est["phi"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "ev", model0 = model_est, est.freq = FALSE, conf.level = NULL)
    res$p.value
  }
  p.values_signal3_me_ar1[[idx]] <- result
}

p.values_signal3_mcos_ar1 <- list()
for (idx in seq_along(Ls)) {
  result <- foreach (
    i = 1:M,
    .combine = 'c',
    .export = functions,
    .packages = packages,
    .options.snow = opts
  ) %dopar% {
    f <- generate_channel(model2, signal3)
    model_est <- arfima_whittle(f, c(NA, 0))
    model_est <- list(phi = model_est["phi"], sigma2 = model_est["sigma2"], N = N)
    res <- mcssa(f, Ls[idx], "cos", model0 = model_est, conf.level = NULL)
    res$p.value
  }
  p.values_signal3_mcos_ar1[[idx]] <- result
}

stopCluster(cluster)
```

```{r eval=FALSE, include=FALSE}
p.values_noise_box_ar1 <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model2)
  model_est <- arfima_whittle(f, c(NA, 0))
  resid <- arima(f, c(1, 0, 0), include.mean = FALSE, fixed = model_est["phi"])$resid
  p.values_noise_box_ar1 <- c(p.values_noise_box_ar1, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal1_box_ar1 <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model2, signal1)
  model_est <- arfima_whittle(f, c(NA, 0))
  resid <- arima(f, c(1, 0, 0), include.mean = FALSE, fixed = model_est["phi"])$resid
  p.values_signal1_box_ar1 <- c(p.values_signal1_box_ar1, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal2_box_ar1 <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model2, signal2)
  model_est <- arfima_whittle(f, c(NA, 0))
  resid <- arima(f, c(1, 0, 0), include.mean = FALSE, fixed = model_est["phi"])$resid
  p.values_signal2_box_ar1 <- c(p.values_signal2_box_ar1, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal3_box_ar1 <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model2, signal3)
  model_est <- arfima_whittle(f, c(NA, 0))
  resid <- arima(f, c(1, 0, 0), include.mean = FALSE, fixed = model_est["phi"])$resid
  p.values_signal3_box_ar1 <- c(p.values_signal3_box_ar1, Box.test(resid, 10, "Ljung-Box", 1)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_noise_wavelet_ar1 <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model2)
  model_est <- arfima_whittle(f, c(NA, 0))
  resid <- arima(f, c(1, 0, 0), include.mean = FALSE, fixed = model_est["phi"])$resid
  p.values_noise_wavelet_ar1 <- c(p.values_noise_wavelet_ar1, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal1_wavelet_ar1 <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model2, signal1)
  model_est <- arfima_whittle(f, c(NA, 0))
  resid <- arima(f, c(1, 0, 0), include.mean = FALSE, fixed = model_est["phi"])$resid
  p.values_signal1_wavelet_ar1 <- c(p.values_signal1_wavelet_ar1, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal2_wavelet_ar1 <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model2, signal2)
  model_est <- arfima_whittle(f, c(NA, 0))
  resid <- arima(f, c(1, 0, 0), include.mean = FALSE, fixed = model_est["phi"])$resid
  p.values_signal2_wavelet_ar1 <- c(p.values_signal2_wavelet_ar1, genwwn.test(resid)$p.value)
}
```

```{r eval=FALSE, include=FALSE}
p.values_signal3_wavelet_ar1 <- c()
set.seed(5)
for (i in 1:M) {
  f <- generate_channel(model2, signal3)
  model_est <- arfima_whittle(f, c(NA, 0))
  resid <- arima(f, c(1, 0, 0), include.mean = FALSE, fixed = model_est["phi"])$resid
  p.values_signal3_wavelet_ar1 <- c(p.values_signal3_wavelet_ar1, genwwn.test(resid)$p.value)
}
```

```{r include=FALSE}
alphaI_mcos <- lapply(p.values_noise_mcos_ar1, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
alphaI_mev <- lapply(p.values_noise_me_ar1, function(pvals) sapply(alphas, function(a) mean(pvals < a)))

alphaI_box <- sapply(alphas, function(a) mean(p.values_noise_box_ar1 < a))
alphaI_wavelet <- sapply(alphas, function(a) mean(p.values_noise_wavelet_ar1 < a))

beta_mev1 <- lapply(p.values_signal1_me_ar1, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_mev2 <- lapply(p.values_signal2_me_ar1, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_mev3 <- lapply(p.values_signal3_me_ar1, function(pvals) sapply(alphas, function(a) mean(pvals < a)))

beta_mcos1 <- lapply(p.values_signal1_mcos_ar1, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_mcos2 <- lapply(p.values_signal2_mcos_ar1, function(pvals) sapply(alphas, function(a) mean(pvals < a)))
beta_mcos3 <- lapply(p.values_signal3_mcos_ar1, function(pvals) sapply(alphas, function(a) mean(pvals < a)))

beta_box1 <- sapply(alphas, function(a) mean(p.values_signal1_box_ar1 < a))
beta_box2 <- sapply(alphas, function(a) mean(p.values_signal2_box_ar1 < a))
beta_box3 <- sapply(alphas, function(a) mean(p.values_signal3_box_ar1 < a))

beta_wavelet1 <- sapply(alphas, function(a) mean(p.values_signal1_wavelet_ar1 < a))
beta_wavelet2 <- sapply(alphas, function(a) mean(p.values_signal2_wavelet_ar1 < a))
beta_wavelet3 <- sapply(alphas, function(a) mean(p.values_signal3_wavelet_ar1 < a))
```

Ошибка первого рода:

```{r echo=FALSE}
plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = "significance level", ylab = 'type I error')
for (i in seq_along(Ls))
  lines(alphas, alphaI_mev[[i]], lwd = lwds[i], col = clrs[i])
lines(alphas, alphaI_box, lwd = 3, col = "darkblue")
lines(alphas, alphaI_wavelet, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

ROC-кривые:

1. Проекция на собственные векторы:

```{r echo=FALSE, fig.width=15}
par(mfrow = c(1, 3))

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.025")
for (i in seq_along(Ls))
  lines(alphaI_mev[[i]], beta_mev1[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box1, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet1, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.125")

for (i in seq_along(Ls))
  lines(alphaI_mev[[i]], beta_mev2[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box2, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet2, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.225")

for (i in seq_along(Ls))
  lines(alphaI_mev[[i]], beta_mev3[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box3, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet3, lwd = 3, col = "brown")
legend(
  x = "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

2. Проекция на косинусы:

a. С поправкой:

```{r echo=FALSE, fig.width=15}
par(mfrow = c(1, 3))

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.025")
for (i in seq_along(Ls))
  lines(alphaI_mcos[[i]], beta_mcos1[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box1, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet1, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.125")

for (i in seq_along(Ls))
  lines(alphaI_mcos[[i]], beta_mcos2[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box2, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet2, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.225")

for (i in seq_along(Ls))
  lines(alphaI_mcos[[i]], beta_mcos3[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box3, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet3, lwd = 3, col = "brown")
legend(
  x = "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```

b. Без поправки:

```{r echo=FALSE, fig.width=15}
par(mfrow = c(1, 3))

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.025")
for (i in seq_along(Ls))
  lines(alphas, beta_mcos1[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box1, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet1, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),,
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.125")

for (i in seq_along(Ls))
  lines(alphas, beta_mcos2[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box2, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet2, lwd = 3, col = "brown")
legend(
  "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)

plot(c(0,1),c(0,1), type="l", col = "blue", lty = 2, xlab = 'type I error', ylab = 'power', main = "frequency = 0.225")

for (i in seq_along(Ls))
  lines(alphas, beta_mcos3[[i]], lwd = lwds[i], col = clrs[i])
lines(alphaI_box, beta_box3, lwd = 3, col = "darkblue")
lines(alphaI_wavelet, beta_wavelet3, lwd = 3, col = "brown")
legend(
  x = "bottomright",
  c("L = 12", "L = 24", "L = 64", "L = 104", "L = 116", "box", "wavelet"),
  col = c(clrs, "darkblue", "brown"),
  lty = 1,
  lwd = c(lwds, 3, 3)
)
```
